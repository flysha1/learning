### 基础知识:

#### 1.元字符

| 元字符 | 说明                       |
| :----: | -------------------------- |
|   .    | 匹配除换行符以外的任意字符 |
|   \w   | 匹配字母、数字、下划线     |
|   \s   | 匹配任意空白字符           |
|   \d   | 匹配任意数字               |
|   \b   | 匹配单词的开始或结束       |
|   ^    | 匹配字符的开始             |
|   \$   | 匹配字符的结束             |

例子：

1. 匹配 abc 开头的字符串:

```javascript
let reg = /abc/ // 或者^abc
```

2.  匹配 8 位数字的 QQ 号码:

```javascript
let reg = /^dddddddd$/
```

3. 匹配 1 开头 11 位数字的手机号码：

```javascript
let reg = /^1dddddddddd$/
```

#### 2.重复限定字符

| 语法  |       说明        |
| :---: | :---------------: |
|  \*   | 重复 0 次或更多次 |
|   +   | 重复 1 次或更多次 |
|   ?   |  重复 0 次或一次  |
|  {n}  |     重复 n 次     |
| {n,}  | 重复 n 次或更多次 |
| {n,m} |  重复 n 到 m 次   |

例子:

1. 匹配 8 位数字的 QQ 号码:

```javascript
let reg = /^\d{8}$/
```

2. 匹配 1 开头 11 位数字的手机号码：

```javascript
let reg = /^1\d{10}$/
```

3. 匹配银行卡号是 14~18 位的数字：

```javascript
let reg = /^\d{14,18}$/
```

4. 匹配以 a 开头的，0 个或多个 b 结尾的字符串:

```javascript
let reg = /^ab*$/
```

#### 3.分组

> 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。

因此当我们要匹配多个 ab 时，我们可以这样

如：匹配字符串中包含 0 到多个 ab 开头：

```javascript
let reg = /^(ab)*/
```

#### 4.转义

我们看到正则表达式用小括号来做分组，那么问题来了：

> 如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？

针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。

如：要匹配以(ab)开头：

```javascript
let reg = /^(\(ab\))*/
```

#### 5.条件或

回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有 130/131/132/155/156/185/186/145/176 等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？

> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

那么我们就可以用或条件来处理这个问题

```javascript
let reg = /^(130|131|132|155|156|185|186|145|176)\d{8}$/
```

#### 6.区间

看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？
实际是有的

> 正则提供一个元字符中括号 [] 来表示区间条件。

1. 限定 0 到 9 可以写成[0-9]
2. 限定 A-Z 写成[A-Z]
3. 限定某些数字 [165]

那上面的正则我们还改成这样：
```javascript
let reg = /^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$/
```

